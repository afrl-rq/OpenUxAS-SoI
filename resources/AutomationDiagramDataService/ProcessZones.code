file << "#! /usr/bin/env python" << std::endl;
file << "" << std::endl;
file << "import xml.dom.minidom" << std::endl;
file << "from xml.dom.minidom import Node" << std::endl;
file << "import pandas as pd" << std::endl;
file << "import glob" << std::endl;
file << "import math" << std::endl;
file << "import LocalCoords  # Conversion module" << std::endl;
file << "" << std::endl;
file << "try:" << std::endl;
file << "    reload  # Python 2.7" << std::endl;
file << "except NameError:" << std::endl;
file << "    try:" << std::endl;
file << "        from importlib import reload  # Python 3.4+" << std::endl;
file << "    except ImportError:" << std::endl;
file << "        from imp import reload  # Python 3.0 - 3.3" << std::endl;
file << "" << std::endl;
file << "def ProcessZone(zoneElement, zoneType):" << std::endl;
file << "    '''\t" << std::endl;
file << "\tReturn zoneID, label, zoneType, and boundary points for a CMASI AbstractZone." << std::endl;
file << "\t" << std::endl;
file << "\t:param zoneElement: An xml.dom.minidom element representing a CMASI AbstractZone message." << std::endl;
file << "\t:param zoneType: A string describing the type of AbstractZone this message implements." << std::endl;
file << "\t:return: A list [zoneID, label, zoneType, boundaryPd], where zoneID is an int, label is a string, " << std::endl;
file << "\t         zoneType is the same as the input parameter, and boundaryPd is a pandas.DataFrame containing columns" << std::endl;
file << "\t         of ['latitude','longitude','altitude'] values that define the zone boundary. In practice, a zone" << std::endl;
file << "\t         boundary extends from MinAltitude to MaxAltitude. The data portion of boundaryPd defaults " << std::endl;
file << "\t         to an Empty Dataframe if a boundary element is not found in zoneElement." << std::endl;
file << "\t'''" << std::endl;
file << "    zoneID = 0" << std::endl;
file << "    elements = zoneElement.getElementsByTagName('ZoneID')" << std::endl;
file << "    if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "        zoneID = int(elements[0].firstChild.data)" << std::endl;
file << "    print('zoneID[' + str(zoneID) + ']')" << std::endl;
file << "    elements = zoneElement.getElementsByTagName('Label')" << std::endl;
file << "    if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "        label = str(elements[0].firstChild.data)" << std::endl;
file << "    else:" << std::endl;
file << "        label = str(zoneID)" << std::endl;
file << "    print('label[' + str(label) + ']')" << std::endl;
file << "    boundaryPoints = []" << std::endl;
file << "    boundaryElements = zoneElement.getElementsByTagName('Boundary')" << std::endl;
file << "    if boundaryElements:" << std::endl;
file << "        boundaryPoints = ProcessAbstractGeometry(boundaryElements[0])" << std::endl;
file << "    if not boundaryPoints:" << std::endl;
file << "        print('Missing boundary for zoneID[' + str(zoneID) + ']')" << std::endl;
file << "    boundaryPd = pd.DataFrame(data=boundaryPoints, columns=['latitude', 'longitude', 'altitude'])" << std::endl;
file << "    return [zoneID, label, zoneType, boundaryPd]" << std::endl;
file << "" << std::endl;
file << "" << std::endl;
file << "def ProcessAbstractGeometry(geometryElement):" << std::endl;
file << "    '''" << std::endl;
file << "\tReturn boundary points for a CMASI AbstractGeometry message." << std::endl;
file << "\t" << std::endl;
file << "\t:param geometryElement: An xml.dom.minidom element representing a CMASI AbstractGeometry message." << std::endl;
file << "\t:return: A list containing [lat, long, alt] elements that define the boundary. If the boundary" << std::endl;
file << "             cannot be constructed, returns an empty list." << std::endl;
file << "\t'''" << std::endl;
file << "    boundaryPoints = []" << std::endl;
file << "    circleElements = geometryElement.getElementsByTagName('Circle')" << std::endl;
file << "    polygonElements = geometryElement.getElementsByTagName('Polygon')" << std::endl;
file << "    rectangleElements = geometryElement.getElementsByTagName('Rectangle')" << std::endl;
file << "    if circleElements:" << std::endl;
file << "        loc3D = []" << std::endl;
file << "        radius = []" << std::endl;
file << "        centerPointElements = circleElements[0].getElementsByTagName('CenterPoint')" << std::endl;
file << "        if centerPointElements:" << std::endl;
file << "            location3DElements = centerPointElements[0].getElementsByTagName('Location3D')" << std::endl;
file << "            if location3DElements:" << std::endl;
file << "                loc3D = ProcessLocation3DElement(location3DElements[0])" << std::endl;
file << "        radiusElements = circleElements[0].getElementsByTagName('Radius')" << std::endl;
file << "        if radiusElements and radiusElements[0].firstChild and radiusElements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "            radius = float(radiusElements[0].firstChild.data)" << std::endl;
file << "        if type(radius) != float or len(loc3D) != 3:" << std::endl;
file << "            return []" << std::endl;
file << "        reload(LocalCoords)  # reset the initialization coordinates" << std::endl;
file << "        centerNorthEast_m = LocalCoords.LatLong_degToNorthEast_m(loc3D[0], loc3D[1])" << std::endl;
file << "        heading = 0;" << std::endl;
file << "        headingStep = math.pi / 18;  # 10 deg steps" << std::endl;
file << "        while heading < 2.0 * math.pi:" << std::endl;
file << "            north_m = radius * math.sin(heading) + centerNorthEast_m[0]" << std::endl;
file << "            east_m = radius * math.cos(heading) + centerNorthEast_m[1]" << std::endl;
file << "            boundaryPointLatLong = LocalCoords.NorthEast_mToLatLong_deg(north_m, east_m)" << std::endl;
file << "            boundaryPoints.append([boundaryPointLatLong[0], boundaryPointLatLong[1], loc3D[2]])" << std::endl;
file << "            heading = heading + headingStep" << std::endl;
file << "    elif polygonElements:" << std::endl;
file << "        boundaryPointElements = polygonElements[0].getElementsByTagName('BoundaryPoints')" << std::endl;
file << "        if boundaryPointElements:" << std::endl;
file << "            location3DElements = boundaryPointElements[0].getElementsByTagName('Location3D')" << std::endl;
file << "            for location3DElement in location3DElements:" << std::endl;
file << "                loc = ProcessLocation3DElement(location3DElement)" << std::endl;
file << "                if loc:" << std::endl;
file << "                    boundaryPoints.append(loc)" << std::endl;
file << "    elif rectangleElements:" << std::endl;
file << "        loc3D = []" << std::endl;
file << "        width = []" << std::endl;
file << "        height = []" << std::endl;
file << "        rotation = []" << std::endl;
file << "        centerPointElements = rectangleElements[0].getElementsByTagName('CenterPoint')" << std::endl;
file << "        if centerPointElements:" << std::endl;
file << "            location3DElements = centerPointElements[0].getElementsByTagName('Location3D')" << std::endl;
file << "            if location3DElements:" << std::endl;
file << "                loc3D = ProcessLocation3DElement(location3DElements[0])" << std::endl;
file << "        elements = rectangleElements[0].getElementsByTagName('Width')" << std::endl;
file << "        if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "            width = float(elements[0].firstChild.data)" << std::endl;
file << "        elements = rectangleElements[0].getElementsByTagName('Height')" << std::endl;
file << "        if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "            height = float(elements[0].firstChild.data)" << std::endl;
file << "        elements = rectangleElements[0].getElementsByTagName('Rotation')" << std::endl;
file << "        if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "            rotation = float(elements[0].firstChild.data)" << std::endl;
file << "        if type(width) != float or type(height) != float or type(rotation) != float or len(loc3D) != 3:" << std::endl;
file << "            return []" << std::endl;
file << "        reload(LocalCoords)  # reset the initialization coordinates" << std::endl;
file << "        centerNorthEast_m = LocalCoords.LatLong_degToNorthEast_m(loc3D[0], loc3D[1])" << std::endl;
file << "        boundaryPointsNorthEast = []" << std::endl;
file << "        boundaryPointsNorthEast.append([centerNorthEast_m[0] + height / 2, centerNorthEast_m[1] - width / 2])" << std::endl;
file << "        boundaryPointsNorthEast.append([centerNorthEast_m[0] + height / 2, centerNorthEast_m[1] + width / 2])" << std::endl;
file << "        boundaryPointsNorthEast.append([centerNorthEast_m[0] - height / 2, centerNorthEast_m[1] + width / 2])" << std::endl;
file << "        boundaryPointsNorthEast.append([centerNorthEast_m[0] - height / 2, centerNorthEast_m[1] - width / 2])" << std::endl;
file << "        for point in boundaryPointsNorthEast:" << std::endl;
file << "            north_m = math.cos(rotation * math.pi / 180.0) * point[0] - math.sin(rotation * math.pi / 180.0) * point[1]" << std::endl;
file << "            east_m = math.sin(rotation * math.pi / 180.0) * point[0] + math.cos(rotation * math.pi / 180.0) * point[1]" << std::endl;
file << "            boundaryPointLatLong = LocalCoords.NorthEast_mToLatLong_deg(north_m, east_m)" << std::endl;
file << "            boundaryPoints.append([boundaryPointLatLong[0], boundaryPointLatLong[1], loc3D[2]])" << std::endl;
file << "    else:" << std::endl;
file << "        print('ERROR:: Unknown boundary area type encountered!!!')" << std::endl;
file << "    return boundaryPoints" << std::endl;
file << "" << std::endl;
file << "" << std::endl;
file << "def ProcessLocation3DElement(Location3DElement):" << std::endl;
file << "    '''" << std::endl;
file << "    Return a list [latitude, longitude, altitude] representing the value of a CMASI Location3D message." << std::endl;
file << "    :param Location3DElement: An xml.dom.minidom element representing a CMASI Location3D message." << std::endl;
file << "    :return: [latitude, longitude, altitude] if the message can be fully processed, [] otherwise." << std::endl;
file << "    '''" << std::endl;
file << "    loc3D = []" << std::endl;
file << "    elements = Location3DElement.getElementsByTagName('Latitude')" << std::endl;
file << "    if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "        loc3D.append(float(elements[0].firstChild.data))" << std::endl;
file << "    elements = Location3DElement.getElementsByTagName('Longitude')" << std::endl;
file << "    if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "        loc3D.append(float(elements[0].firstChild.data))" << std::endl;
file << "    elements = Location3DElement.getElementsByTagName('Altitude')" << std::endl;
file << "    if elements and elements[0].firstChild and elements[0].firstChild.nodeType == Node.TEXT_NODE:" << std::endl;
file << "        loc3D.append(float(elements[0].firstChild.data))" << std::endl;
file << "    if len(loc3D) == 3:" << std::endl;
file << "        return loc3D" << std::endl;
file << "    else:" << std::endl;
file << "        return []" << std::endl;
file << "" << std::endl;
file << "" << std::endl;
file << "def ProcessZoneFile(filename):" << std::endl;
file << "    zones = []" << std::endl;
file << "    doc2 = xml.dom.minidom.parse(filename)" << std::endl;
file << "    if doc2.hasChildNodes():" << std::endl;
file << "        isGoodMessage = True" << std::endl;
file << "        zoneNode = doc2.firstChild" << std::endl;
file << "        zoneType = ''" << std::endl;
file << "        if str(zoneNode.nodeName) == 'KeepInZone':" << std::endl;
file << "            zoneType = 'KeepInZone'" << std::endl;
file << "        elif str(zoneNode.nodeName) == 'KeepOutZone':" << std::endl;
file << "            zoneType = 'KeepOutZone'" << std::endl;
file << "        else:" << std::endl;
file << "            print('ERROR:: Unknown zone type[' + str(zoneNode.nodeName) + '] encountered!!!')" << std::endl;
file << "            isGoodMessage = False" << std::endl;
file << "        if isGoodMessage:" << std::endl;
file << "            zones.append(ProcessZone(zoneNode, zoneType))" << std::endl;
file << "    return zones" << std::endl;
file << "" << std::endl;
file << "" << std::endl;
file << "def main():" << std::endl;
file << "    zoneArray = []" << std::endl;
file << "    for zoneFile in glob.glob('ZoneKeep*'):" << std::endl;
file << "        print('loading [' + zoneFile + ']')" << std::endl;
file << "        zoneArray.extend(ProcessZoneFile(zoneFile))" << std::endl;
file << "    zoneArrayPd = pd.DataFrame(data=zoneArray, columns=['zoneID', 'label', 'zoneType', 'boundaryPd'])" << std::endl;
file << "    print('saving [Zones.pkl]')" << std::endl;
file << "    zoneArrayPd.to_pickle('Zones.pkl')" << std::endl;
file << "" << std::endl;
file << "" << std::endl;
file << "if __name__ == '__main__':" << std::endl;
file << "    main()" << std::endl;
