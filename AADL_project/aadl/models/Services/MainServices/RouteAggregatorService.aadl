package RouteAggregatorService_Pkg
public
	with CMASI;
    with UXTASK;
    with IMPACT;
    with ROUTE;
    with UxAS_Node_Lib;

	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RouteAggregatorService; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			lemma "num_route_requests_being_serviced >= 0" : sub.num_route_requests_being_serviced >= 0;
			
			--State machine lemmas
			lemma "The value of the state variable corresponds to a 'real' state." :
				(sub.state = sub.IDLE) 
				or (sub.state = sub.PENDING);
			lemma "Only stated transitions are allowed." :
				sub.some_transition or (sub.state = sub.previous_state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "False indicates the IDLE state is reachable" : not (sub.state = sub.IDLE); 
			lemma "False indicates the PENDING state is reachable" : not (sub.state = sub.PENDING);
			
			--Check that all state transitions are reachable
			lemma "False indicates that T_IDLE_TO_PENDING is reachable" : not sub.T_IDLE_TO_PENDING;
			lemma "False indicates that T_PENDING_TO_IDLE is reachable": not sub.T_PENDING_TO_IDLE;
			
			--Check that events are possible
			lemma "False indicates the system is able to produce a route response" : not event(sub.RouteResponse_out);
			lemma "False indicates the system is able to produce a route plan request" : not event(sub.RoutePlanRequest_out);
			lemma "False indicates the system is able to receive a route plan response": not event(sub.RouteRequest_in);
			lemma "False indicates the system is able to receive a route request": not event(sub.RoutePlanResponse_in);
		**};
		 
	end top_level.Impl;	
	
thread RouteAggregatorService
    features
        GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i;
        SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i;
        AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
        RouteRequest_in: in event data port route::RouteRequest.i;
        GroundVehicleState_in: in event data port impact::GroundVehicleState.i;
        UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i;
        RoutePlanResponse_in: in event data port route::RoutePlanResponse.i;
        SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
        TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i;
        AirVehicleState_in: in event data port cmasi::AirVehicleState.i;
        ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
        RoutePlanRequest_out: out event data port route::RoutePlanRequest.i;
        AssignmentCostMatrix_out: out event data port uxtask::AssignmentCostMatrix.i;
        RouteResponse_out: out event data port route::RouteResponse.i;
   	annex agree{**
   		-------------------------------------------------------------
   		-- Note: I'm not sure we need to model this IDLE <--> PENDING state machine,
   		--  but I'm keeping it for now. This is described in the Wiki.
   		--  We're not yet sure if we'll want to refer to this service's state in our system-level
   		--  guarantees.
  		-------------------------------------------------------------
  		-- BEGIN STATE MACHINE LOGIC
		-------------------------------------------------------------
		--State constants
 		const IDLE : int = 0;
        const PENDING : int = 1;

		-------------------------------------------------------------
		--State variable
		eq state: int;

		-------------------------------------------------------------
		--State machine support macros		

		eq previous_state: int = prev(state, IDLE);

		eq some_transition: bool = T_IDLE_TO_PENDING
									or T_PENDING_TO_IDLE;

		-------------------------------------------------------------
		--Helper macro for this particular state machine
		eq num_route_requests_being_serviced : int = 
			0 -> 
				(pre(num_route_requests_being_serviced) 
					+ UxAS_Node_Lib.bool_to_int(event(RouteRequest_in)) 
					- UxAS_Node_Lib.bool_to_int(event(RouteResponse_out))
				);
				
		-------------------------------------------------------------	
		--State transition macros
		
		--This is initially false to prevent transition to PENDING on the initial timestep
		--Note: The documentation seems to say we also need to create a table and send the RoutePlanRequest messages
		--  before moving to IDLE. We could possibly introduce another state between IDLE and PENDING for "setup"; 
		--  but since I'm not modeling those details currently, I think it's okay to move to PENDING as soon as we receive
		--  RouteRequest_in.
		eq T_IDLE_TO_PENDING : bool = 
			false -> ((previous_state = IDLE) and event(RouteRequest_in));
		
		--Since we may be servicing multiple requests at a time, we stay in pending until all requests have been 
		-- serviced, in which case we return to IDLE
		eq T_PENDING_TO_IDLE : bool = 
			(previous_state = PENDING) and (num_route_requests_being_serviced = 0);
			
		-------------------------------------------------------------	
		--State machine guarantees
				
		--This guarantee specifies the initial state.
        guarantee "Initial_State": (state = IDLE) -> true;
        
        --This guarantee captures all the "self loops" in shorthand form. 
        -- It is important to state what happens when no transition condition is satisfied.
        -- Otherwise the model checker will allow "spontaneous" transitions.
        guarantee "Self loops": not some_transition => (state = previous_state);
        
        -- Now we write one guarantee for each transition.
        
        --If we had other actions to take on this transition, we would include those in the consequent as well. 
        guarantee "T_IDLE_TO_PENDING_effect" : T_IDLE_TO_PENDING => (state = PENDING);
        
        guarantee "T_PENDING_TO_IDLE_effect" : T_PENDING_TO_IDLE => (state = IDLE);

		-------------------------------------------------------------
		-- END STATE MACHINE LOGIC
		-------------------------------------------------------------
		
		-------------------------------------------------------------
		-------------------------------------------------------------
		-- The guarantees in this section capture correct component behavior.
		-- The set is still not complete though.
		
		guarantee "Only produce a route response when previous state was PENDING": 
			event(RouteResponse_out) => (previous_state = PENDING);
	
		guarantee "Only produce a route plan request when the previous state was PENDING": 
			event(RoutePlanRequest_out) => (previous_state = PENDING);	

		-- Should we pick a time window so that we can state the following property? 
		--   RouteRequest_in => within X we get a RouteResponse_out with a matching ID
		--   We would need to assume that the route planners respond in a timely manner
		--   in order to guarantee that.

		-------------------------------------------------------------
		-- Guarantees that need arrays, or records mimicking arrays, to formally express.
		
		-- The locations and destinations (first and last waypoints) of the route plans in the responses should match the requests, or an error should be produced.
		-- This is something the route planners should guarantee, and we could check that the originator of the RouteRequst receives 
		-- routes that satisfy this if we could guarantee that this RouteAggregator Service passed on the routes from the planners without
		-- modifying them, but we can't do that without building the array of responses or changing the data structure (interface)
		-- somehow.	
		
		eq route_response_consists_of_route_plan_responses_received : bool;
		guarantee "The routes in RouteResponse_out are the route plan responses received." :
			route_response_consists_of_route_plan_responses_received;
		
		eq route_plan_request_sent_for_each_vehicleID : bool;	
		guarantee "For each vehicle ID in the VehicleID array of the route request, a route plan request message is sent
		    with a matchine Vehicle ID (and the rest of the contents the same)":
		    route_plan_request_sent_for_each_vehicleID;
		
		-------------------------------------------------------------
		-- The guarantees below this line depend on some internal state. That is difficult to
		--  express for a RouteAggregatorService that can service an arbitrary number of 
		--  requests at a time. We would be forced to fix the number it can serve to some max
		--  for modeling purposes. Not sure we want to do that.
		--  Q for Sean/Derek: Does it really serve an arbitrary number or is there a max?
		--
		-- Note: I do have a formal version of these guarantee in RouteAggregatorService_OneRequestAtATime
		--
		eq contents_of_route_plan_requests_match_contents_of_route_request : bool;
		guarantee "Contents of route plan requests match contents of route request (execept VehicleID and RequestID)" :
			contents_of_route_plan_requests_match_contents_of_route_request;

		-- Should we pick a time window so that we can state the following property? 
		--   RouteRequest_in => within X we get a RouteResponse_out with a matching ID
		--   We would need to assume that the route planners respond in a timely manner
		--   in order to guarantee that. 	

		-- We may want to add a guarantee about sending the route plan requests within some
		--  timeframe. For now, as modeled, this service could sit on them forever. 
		
		eq produce_route_resonse_once_with_matching_ID_once_all_route_plan_responses_have_been_received : bool;
		guarantee "Produce route response output with matching ID once all route plan responses have been received" : 
			produce_route_resonse_once_with_matching_ID_once_all_route_plan_responses_have_been_received;
		
		-- Q: Is the ResponseID in the route plan responses enough to ensure the message is the response we're expecting? 
		-- Do we have any system-level guarantees about uniqueness of these IDs? 
			
		------------------------------------------------------------
		-- Below is some Q&A. Discussion held 6/13/17 with Jen, Aaron, Sean, Ben R., and John B. 
		
		-- Q: What will the top-level UxAS use from this? It doesn't have visibility into the internal state... 
		-- John: Modeling the state makes sense if we have a system-level guarantee that references it.
		-- Ben: Higher level req may be if all responses are received, response is sent out.
		-- John: We could try to figure out our system-level reqts first and model the Wiki more coarsely.
		
		-- Q (Philosophical): Should component contracts include only what we need for architectural level reasoning,
		--  or should the contracts be sufficiently detailed so that any component satisfying the contract will
		--  result in a correctly functioning system? Or would one argue that these are in fact the same?
		-- John: In general, a component contract should have at least enough info to prove system-level reqts.
		-- 	Component reqts need to trace to some system reqt.
		-- Ben: But sometimes we build components out of context. Maybe some are identified for "plug-and-play." Those may
		--  be over-designed.
		-- Aaron: Contracts should ensure that a replacement component gives us the same functionality that we had 
		--  previously. 
		 
		--  Currently, my contracts on this component are not nearly sufficient to ensure correctness. The output
		--  messages could be jibberish. Even if I require the response ID to match the request ID, the
		--  rest of the information could be garbage.

	**};
end RouteAggregatorService;

end RouteAggregatorService_Pkg;